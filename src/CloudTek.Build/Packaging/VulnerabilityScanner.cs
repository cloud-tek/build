using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;
using Nuke.Common.Tooling;

namespace CloudTek.Build.Packaging;

internal class VulnerabilityScanner
{
  private static readonly Regex ProjectRegex = new Regex(
    "Project `(.*)` has the following vulnerable packages",
    RegexOptions.Compiled);

  private static readonly Regex PackageRegex = new Regex(
    "\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)",
    RegexOptions.Compiled);

  internal record Vulnerability(
    string Repository,
    string Project,
    string PackageName,
    string ResolvedVersion,
    string Severity,
    string AdvisoryUrl,
    PackageType PackageLevel);

  internal static void ReportScan(SmartBuild build, string repositoryName, IReadOnlyCollection<Output> outputs)
  {
    var scanOutputLines = outputs.Select(p => p.Text).ToList();
    var vulnerabilities = GetVulnerabilities(repositoryName, scanOutputLines);

    if (vulnerabilities.Any())
    {
      var logger = build.LoggerFactory?.CreateLogger<VulnerabilityScanner>();
      var guid = Guid.NewGuid();

      vulnerabilities.ForEach(
        p =>
        {
#pragma warning disable CA1848,CA1727
          logger?.LogInformation(
            "Vulnerability info ({buildGuid}): {repository}, {project}, {packageLevel}, {package}, {resolvedVersion}, {severity}, {advisoryUrl}",
            guid,
            p.Repository,
            p.Project,
            p.PackageLevel,
            p.PackageName,
            p.ResolvedVersion,
            p.Severity,
            p.AdvisoryUrl);
#pragma warning restore CA1848,CA1727
        });

      var grouped = vulnerabilities.GroupBy(p => new { p.Repository, p.Project, p.PackageLevel, p.Severity });

#pragma warning disable CA1848,CA1727
      logger?.LogInformation(
        "{vulnerabilitiesCount} vulnerabilities found [total] for {repository} - {buildGuid}!",
        vulnerabilities
          .Count,
        repositoryName,
        guid);
#pragma warning restore CA1848,CA1727
      foreach (var group in grouped)
      {
#pragma warning disable CA1848,CA1727
        logger?.LogInformation(
          "{vulnerabilitiesCount} {packageLevel} {severity} vulnerabilities found for {repository} - {project} - {buildGuid}!",
          group.Count(),
          group.Key.PackageLevel,
          group.Key.Severity,
          group.Key.Repository,
          group.Key.Project,
          guid);
#pragma warning restore CA1848,CA1727
      }
    }
  }

  private static List<Vulnerability> GetVulnerabilities(
    string repositoryName,
    IReadOnlyCollection<string> outputs)
  {
    var result = new List<Vulnerability>();
    string? project = null;
    var isTransitive = false;
    string? package = null;
    string? resolvedVersion = null;

    foreach (var output in outputs)
    {
      if (output.StartsWith("Project", StringComparison.InvariantCulture))
      {
        var match = ProjectRegex.Match(output);
        project = match.Groups[1].Value;
        continue;
      }

      if (output.Contains("Top-level Package"))
      {
        isTransitive = false;
        continue;
      }

      if (output.Contains("Transitive Package"))
      {
        isTransitive = true;
        continue;
      }

      if (output.Contains('>'))
      {
        var match = PackageRegex.Match(output);
        package = match.Groups[2].Value;
        resolvedVersion = isTransitive ? match.Groups[3].Value : match.Groups[4].Value;
        var severity = isTransitive ? match.Groups[4].Value : match.Groups[5].Value;
        var advisoryUrl = isTransitive ? match.Groups[5].Value : match.Groups[6].Value;
        result.Add(
          new Vulnerability(
            repositoryName,
            project ?? "unknown",
            package,
            resolvedVersion,
            severity,
            advisoryUrl,
            isTransitive ? PackageType.Transitive : PackageType.Top));
      }
      else if (output.StartsWith("       ", StringComparison.InvariantCulture) && output.Contains("https"))
      {
        var match = PackageRegex.Match(output);
        var severity = match.Groups[1].Value;
        var advisoryUrl = match.Groups[2].Value;
        result.Add(
          new Vulnerability(
            repositoryName,
            project ?? "unknown",
            package ?? "unknown",
            resolvedVersion ?? "unknown",
            severity,
            advisoryUrl,
            isTransitive ? PackageType.Transitive : PackageType.Top));
      }
    }

    return result;
  }
}