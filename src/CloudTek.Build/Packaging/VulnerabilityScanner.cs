using System.Text.RegularExpressions;
using Microsoft.Extensions.Logging;

using static Nuke.Common.Tools.DotNet.DotNetTasks;

namespace CloudTek.Build.Packaging;

#pragma warning disable CA1848,CA1727
internal class VulnerabilityScanner
{
  private static readonly Regex ProjectRegex = new Regex("Project `(.*)` has the following vulnerable packages", RegexOptions.Compiled);

  private static readonly Regex PackageRegex = new Regex("\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)", RegexOptions.Compiled);

  private static readonly Guid BuildGuid = Guid.NewGuid();

  private const string   private const string Unknown = "unknown";
    = "unknown";

  internal static void Scan(SmartBuild build)
  {
    var outputs = DotNet(
      "list package --vulnerable --include-transitive --source https://api.nuget.org/v3/index.json",
      build.Solution.Directory);
    var scanOutputLines = outputs.Select(p => p.Text).ToList();
    var vulnerabilities = ParseVulnerabilities(build.Repository.Name, scanOutputLines);

    if (vulnerabilities.Any())
    {
      var logger = build.LoggerFactory?.CreateLogger<VulnerabilityScanner>();

      vulnerabilities.ForEach(
        p =>
        {
          logger?.LogInformation(
            "Vulnerability ({buildGuid}): {repository}, {project}, {packageLevel}, {package}, {resolvedVersion}, {severity}, {advisoryUrl}",
            BuildGuid,
            p.Repository,
            p.Project,
            p.DependencyType,
            p.Package,
            p.Version,
            p.Severity,
            p.AdvisoryUrl);
        });

      var grouped = vulnerabilities.GroupBy(p => new { p.Repository, p.Project, p.DependencyType, p.Severity });
      logger?.LogInformation(
        "Total of {vulnerabilitiesCount} vulnerabilities found for {repository} {buildGuid}!",
        vulnerabilities
          .Count,
        build.Repository.Name,
        BuildGuid);

      foreach (var group in grouped)
      {
        logger?.LogInformation(
          "{vulnerabilitiesCount} {packageLevel} {severity} vulnerabilities found for {repository}/{project} - {buildGuid}!",
          group.Count(),
          group.Key.DependencyType,
          group.Key.Severity,
          group.Key.Repository,
          group.Key.Project,
          BuildGuid);
      }
    }
  }

  private static List<Vulnerability> ParseVulnerabilities(
    string repositoryName,
    IReadOnlyCollection<string> outputs)
  {
    var result = new List<Vulnerability>();
    string? project = null;
    var isTransitive = false;
    string? package = null;
    string? version = null;

    foreach (var output in outputs)
    {
      if (output.StartsWith("Project", StringComparison.InvariantCulture))
      {
        var match = ProjectRegex.Match(output);
        project = match.Groups[1].Value;
        continue;
      }

      if (output.Contains("Top-level Package"))
      {
        isTransitive = false;
        continue;
      }

      if (output.Contains("Transitive Package"))
      {
        isTransitive = true;
        continue;
      }

      if (output.Contains('>'))
      {
        var match = PackageRegex.Match(output);
        package = match.Groups[2].Value;
        version = isTransitive ? match.Groups[3].Value : match.Groups[4].Value;
        var severity = isTransitive ? match.Groups[4].Value : match.Groups[5].Value;
        var advisoryUrl = isTransitive ? match.Groups[5].Value : match.Groups[6].Value;
        result.Add(
          new Vulnerability(
            repositoryName,
            project ?? Unknown,
            package,
            version,
            severity,
            advisoryUrl,
            isTransitive ? DependencyType.Transitive : DependencyType.Top));
      }
      else if (output.StartsWith("       ", StringComparison.InvariantCulture) && output.Contains("https"))
      {
        var match = PackageRegex.Match(output);
        var severity = match.Groups[1].Value;
        var advisoryUrl = match.Groups[2].Value;
        result.Add(
          new Vulnerability(
            repositoryName,
            project ?? Unknown,
            package ?? Unknown,
            version ?? Unknown,
            severity,
            advisoryUrl,
            isTransitive ? DependencyType.Transitive : DependencyType.Top));
      }
    }

    return result;
  }

  private record Vulnerability(
    string Repository,
    string Project,
    string Package,
    string Version,
    string Severity,
    string AdvisoryUrl,
    DependencyType DependencyType);
}
#pragma warning restore CA1848,CA1727