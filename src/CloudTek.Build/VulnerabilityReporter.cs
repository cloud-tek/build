using System.Text.RegularExpressions;
using CloudTek.Build.Packaging;
using Microsoft.Extensions.Logging;

namespace CloudTek.Build;

internal class VulnerabilityReporter
{
  private static readonly Regex ProjectRegex = new Regex(
    "Project `(.*)` has the following vulnerable packages",
    RegexOptions.Compiled);

  private static readonly Regex PackageRegex = new Regex(
    "\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)",
    RegexOptions.Compiled);

  public static readonly ILogger<VulnerabilityReporter> TelemetryLogger =
    SmartBuild.LoggerFactory.CreateLogger<VulnerabilityReporter>();

  internal record VulnerabilityInfo(
    string Repository,
    string Project,
    string PackageName,
    string ResolvedVersion,
    string Severity,
    string AdvisoryUrl,
    PackageType PackageLevel);

  internal static void ReportScan(string repositoryName, IReadOnlyCollection<string> scanOutputLines)
  {
    var vulnerabilityInfoList = CalculateVulnerabilities(repositoryName, scanOutputLines);

    var guid = Guid.NewGuid();

    vulnerabilityInfoList.ForEach(
      p =>
      {
#pragma warning disable CA1848,CA1727
        TelemetryLogger.LogInformation(
          "Vulnerability info ({buildGuid}): {repository}, {project}, {packageLevel}, {package}, {resolvedVersion}, {severity}, {advisoryUrl}",
          guid,
          p.Repository,
          p.Project,
          p.PackageLevel,
          p.PackageName,
          p.ResolvedVersion,
          p.Severity,
          p.AdvisoryUrl);
#pragma warning restore CA1848,CA1727
      });

    var grouped = vulnerabilityInfoList.GroupBy(p => new { p.Repository, p.Project, p.PackageLevel, p.Severity });

#pragma warning disable CA1848,CA1727
    TelemetryLogger.LogInformation(
      "{vulnerabilitiesCount} vulnerabilities found [total] for {repository} - {buildGuid}!",
      vulnerabilityInfoList
        .Count,
      repositoryName,
      guid);
#pragma warning restore CA1848,CA1727
    foreach (var group in grouped)
    {
#pragma warning disable CA1848,CA1727
      TelemetryLogger.LogInformation(
        "{vulnerabilitiesCount} {packageLevel} {severity} vulnerabilities found for {repository} - {project} - {buildGuid}!",
        group.Count(),
        group.Key.PackageLevel,
        group.Key.Severity,
        group.Key.Repository,
        group.Key.Project,
        guid);
#pragma warning restore CA1848,CA1727
    }
  }

  private static List<VulnerabilityInfo> CalculateVulnerabilities(
    string repositoryName,
    IReadOnlyCollection<string> outputs)
  {
    var vulnerabilityInfoList = new List<VulnerabilityInfo>();
    string? project = null;
    var isTransitive = false;
    string? package = null;
    string? resolvedVersion = null;
    foreach (var output in outputs)
    {
      if (output.StartsWith("Project", StringComparison.InvariantCulture))
      {
        var match = ProjectRegex.Match(output);
        project = match.Groups[1].Value;
        continue;
      }

      if (output.Contains("Top-level Package"))
      {
        isTransitive = false;
        continue;
      }

      if (output.Contains("Transitive Package"))
      {
        isTransitive = true;
        continue;
      }

      if (output.Contains('>'))
      {
        var match = PackageRegex.Match(output);
        package = match.Groups[2].Value;
        resolvedVersion = isTransitive ? match.Groups[3].Value : match.Groups[4].Value;
        var severity = isTransitive ? match.Groups[4].Value : match.Groups[5].Value;
        var advisoryUrl = isTransitive ? match.Groups[5].Value : match.Groups[6].Value;
        vulnerabilityInfoList.Add(
          new VulnerabilityInfo(
            repositoryName,
            project ?? "unknown",
            package,
            resolvedVersion,
            severity,
            advisoryUrl,
            isTransitive ? PackageType.Transitive : PackageType.Top));
      }
      else if (output.StartsWith("       ", StringComparison.InvariantCulture) && output.Contains("https"))
      {
        var match = PackageRegex.Match(output);
        var severity = match.Groups[1].Value;
        var advisoryUrl = match.Groups[2].Value;
        vulnerabilityInfoList.Add(
          new VulnerabilityInfo(
            repositoryName,
            project ?? "unknown",
            package ?? "unknown",
            resolvedVersion ?? "unknown",
            severity,
            advisoryUrl,
            isTransitive ? PackageType.Transitive : PackageType.Top));
      }
    }

    return vulnerabilityInfoList;
  }
}